
# Напишите декоратор, который будет сохранять результаты
# выполнения декорируемой функции в словаре. Словарь должен
# находиться в nonlocal области в следующем формате: по ключу
# располагается аргумент функции, по значению — результат работы
# функции, например, {n: f(n)}.
#
# И при повторном вызове функции декоратор будет брать значение
# из словаря, а не вычислять заново. То есть словарь можно считать
# промежуточной памятью на время работы программы, где будут храниться
# ранее вычисленные значения. Исходная функция, которую нужно задекорировать
# имеет следующий вид и выполняет простое умножение на число 123456789:

def decorator(func):
    cash = {}

    def wrapper(num):
        nonlocal cash
        if num not in cash:
            cash[num] = func(num)
            print(f" Добавление результата в кэш: {cash[num]}")
        else:
            print(f"Возвращение результата из кэша: {cash[num]}")
        print(f"Кэш {cash}")
        return cash[num]
    return wrapper


def f(n):
   return n * 123456789

r = decorator(f)

r(2)
r(3)
r(4)
r(2)
